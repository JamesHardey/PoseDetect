
/**
 * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
 *
 * Do not edit this file as changes may cause incorrect behavior and will be lost
 * once the code is regenerated.
 *
 * @generated by codegen project: GeneratePropsH.js
 */
#pragma once

#include <react/renderer/components/view/ViewProps.h>
#include <react/renderer/core/PropsParserContext.h>
#include <react/renderer/core/propsConversions.h>
#include <react/renderer/debug/DebugStringConvertible.h>
#include <react/renderer/graphics/Color.h>
#include <react/renderer/imagemanager/primitives.h>
#include <vector>

namespace facebook::react {

class RNSFullWindowOverlayProps final : public ViewProps {
 public:
  RNSFullWindowOverlayProps() = default;
  RNSFullWindowOverlayProps(const PropsParserContext& context, const RNSFullWindowOverlayProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  bool accessibilityContainerViewIsModal{true};

  #ifdef RN_SERIALIZABLE_STATE
  ComponentName getDiffPropsImplementationTarget() const override;

  folly::dynamic getDiffProps(const Props* prevProps) const override;
  #endif

  
};

enum class RNSSplitViewHostPreferredDisplayMode { Automatic, SecondaryOnly, OneBesideSecondary, OneOverSecondary, TwoBesideSecondary, TwoOverSecondary, TwoDisplaceSecondary };

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSSplitViewHostPreferredDisplayMode &result) {
  auto string = (std::string)value;
  if (string == "automatic") { result = RNSSplitViewHostPreferredDisplayMode::Automatic; return; }
  if (string == "secondaryOnly") { result = RNSSplitViewHostPreferredDisplayMode::SecondaryOnly; return; }
  if (string == "oneBesideSecondary") { result = RNSSplitViewHostPreferredDisplayMode::OneBesideSecondary; return; }
  if (string == "oneOverSecondary") { result = RNSSplitViewHostPreferredDisplayMode::OneOverSecondary; return; }
  if (string == "twoBesideSecondary") { result = RNSSplitViewHostPreferredDisplayMode::TwoBesideSecondary; return; }
  if (string == "twoOverSecondary") { result = RNSSplitViewHostPreferredDisplayMode::TwoOverSecondary; return; }
  if (string == "twoDisplaceSecondary") { result = RNSSplitViewHostPreferredDisplayMode::TwoDisplaceSecondary; return; }
  abort();
}

static inline std::string toString(const RNSSplitViewHostPreferredDisplayMode &value) {
  switch (value) {
    case RNSSplitViewHostPreferredDisplayMode::Automatic: return "automatic";
    case RNSSplitViewHostPreferredDisplayMode::SecondaryOnly: return "secondaryOnly";
    case RNSSplitViewHostPreferredDisplayMode::OneBesideSecondary: return "oneBesideSecondary";
    case RNSSplitViewHostPreferredDisplayMode::OneOverSecondary: return "oneOverSecondary";
    case RNSSplitViewHostPreferredDisplayMode::TwoBesideSecondary: return "twoBesideSecondary";
    case RNSSplitViewHostPreferredDisplayMode::TwoOverSecondary: return "twoOverSecondary";
    case RNSSplitViewHostPreferredDisplayMode::TwoDisplaceSecondary: return "twoDisplaceSecondary";
  }
}

#ifdef RN_SERIALIZABLE_STATE
static inline folly::dynamic toDynamic(const RNSSplitViewHostPreferredDisplayMode &value) {
  return toString(value);
}
#endif
enum class RNSSplitViewHostPreferredSplitBehavior { Automatic, Displace, Overlay, Tile };

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSSplitViewHostPreferredSplitBehavior &result) {
  auto string = (std::string)value;
  if (string == "automatic") { result = RNSSplitViewHostPreferredSplitBehavior::Automatic; return; }
  if (string == "displace") { result = RNSSplitViewHostPreferredSplitBehavior::Displace; return; }
  if (string == "overlay") { result = RNSSplitViewHostPreferredSplitBehavior::Overlay; return; }
  if (string == "tile") { result = RNSSplitViewHostPreferredSplitBehavior::Tile; return; }
  abort();
}

static inline std::string toString(const RNSSplitViewHostPreferredSplitBehavior &value) {
  switch (value) {
    case RNSSplitViewHostPreferredSplitBehavior::Automatic: return "automatic";
    case RNSSplitViewHostPreferredSplitBehavior::Displace: return "displace";
    case RNSSplitViewHostPreferredSplitBehavior::Overlay: return "overlay";
    case RNSSplitViewHostPreferredSplitBehavior::Tile: return "tile";
  }
}

#ifdef RN_SERIALIZABLE_STATE
static inline folly::dynamic toDynamic(const RNSSplitViewHostPreferredSplitBehavior &value) {
  return toString(value);
}
#endif
enum class RNSSplitViewHostPrimaryEdge { Leading, Trailing };

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSSplitViewHostPrimaryEdge &result) {
  auto string = (std::string)value;
  if (string == "leading") { result = RNSSplitViewHostPrimaryEdge::Leading; return; }
  if (string == "trailing") { result = RNSSplitViewHostPrimaryEdge::Trailing; return; }
  abort();
}

static inline std::string toString(const RNSSplitViewHostPrimaryEdge &value) {
  switch (value) {
    case RNSSplitViewHostPrimaryEdge::Leading: return "leading";
    case RNSSplitViewHostPrimaryEdge::Trailing: return "trailing";
  }
}

#ifdef RN_SERIALIZABLE_STATE
static inline folly::dynamic toDynamic(const RNSSplitViewHostPrimaryEdge &value) {
  return toString(value);
}
#endif
enum class RNSSplitViewHostDisplayModeButtonVisibility { Always, Automatic, Never };

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSSplitViewHostDisplayModeButtonVisibility &result) {
  auto string = (std::string)value;
  if (string == "always") { result = RNSSplitViewHostDisplayModeButtonVisibility::Always; return; }
  if (string == "automatic") { result = RNSSplitViewHostDisplayModeButtonVisibility::Automatic; return; }
  if (string == "never") { result = RNSSplitViewHostDisplayModeButtonVisibility::Never; return; }
  abort();
}

static inline std::string toString(const RNSSplitViewHostDisplayModeButtonVisibility &value) {
  switch (value) {
    case RNSSplitViewHostDisplayModeButtonVisibility::Always: return "always";
    case RNSSplitViewHostDisplayModeButtonVisibility::Automatic: return "automatic";
    case RNSSplitViewHostDisplayModeButtonVisibility::Never: return "never";
  }
}

#ifdef RN_SERIALIZABLE_STATE
static inline folly::dynamic toDynamic(const RNSSplitViewHostDisplayModeButtonVisibility &value) {
  return toString(value);
}
#endif
enum class RNSSplitViewHostOrientation { Inherit, All, AllButUpsideDown, Portrait, PortraitUp, PortraitDown, Landscape, LandscapeLeft, LandscapeRight };

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSSplitViewHostOrientation &result) {
  auto string = (std::string)value;
  if (string == "inherit") { result = RNSSplitViewHostOrientation::Inherit; return; }
  if (string == "all") { result = RNSSplitViewHostOrientation::All; return; }
  if (string == "allButUpsideDown") { result = RNSSplitViewHostOrientation::AllButUpsideDown; return; }
  if (string == "portrait") { result = RNSSplitViewHostOrientation::Portrait; return; }
  if (string == "portraitUp") { result = RNSSplitViewHostOrientation::PortraitUp; return; }
  if (string == "portraitDown") { result = RNSSplitViewHostOrientation::PortraitDown; return; }
  if (string == "landscape") { result = RNSSplitViewHostOrientation::Landscape; return; }
  if (string == "landscapeLeft") { result = RNSSplitViewHostOrientation::LandscapeLeft; return; }
  if (string == "landscapeRight") { result = RNSSplitViewHostOrientation::LandscapeRight; return; }
  abort();
}

static inline std::string toString(const RNSSplitViewHostOrientation &value) {
  switch (value) {
    case RNSSplitViewHostOrientation::Inherit: return "inherit";
    case RNSSplitViewHostOrientation::All: return "all";
    case RNSSplitViewHostOrientation::AllButUpsideDown: return "allButUpsideDown";
    case RNSSplitViewHostOrientation::Portrait: return "portrait";
    case RNSSplitViewHostOrientation::PortraitUp: return "portraitUp";
    case RNSSplitViewHostOrientation::PortraitDown: return "portraitDown";
    case RNSSplitViewHostOrientation::Landscape: return "landscape";
    case RNSSplitViewHostOrientation::LandscapeLeft: return "landscapeLeft";
    case RNSSplitViewHostOrientation::LandscapeRight: return "landscapeRight";
  }
}

#ifdef RN_SERIALIZABLE_STATE
static inline folly::dynamic toDynamic(const RNSSplitViewHostOrientation &value) {
  return toString(value);
}
#endif
enum class RNSSplitViewHostPrimaryBackgroundStyle { Default, None, Sidebar };

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSSplitViewHostPrimaryBackgroundStyle &result) {
  auto string = (std::string)value;
  if (string == "default") { result = RNSSplitViewHostPrimaryBackgroundStyle::Default; return; }
  if (string == "none") { result = RNSSplitViewHostPrimaryBackgroundStyle::None; return; }
  if (string == "sidebar") { result = RNSSplitViewHostPrimaryBackgroundStyle::Sidebar; return; }
  abort();
}

static inline std::string toString(const RNSSplitViewHostPrimaryBackgroundStyle &value) {
  switch (value) {
    case RNSSplitViewHostPrimaryBackgroundStyle::Default: return "default";
    case RNSSplitViewHostPrimaryBackgroundStyle::None: return "none";
    case RNSSplitViewHostPrimaryBackgroundStyle::Sidebar: return "sidebar";
  }
}

#ifdef RN_SERIALIZABLE_STATE
static inline folly::dynamic toDynamic(const RNSSplitViewHostPrimaryBackgroundStyle &value) {
  return toString(value);
}
#endif
enum class RNSSplitViewHostTopColumnForCollapsing { Default, Primary, Supplementary, Secondary };

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSSplitViewHostTopColumnForCollapsing &result) {
  auto string = (std::string)value;
  if (string == "default") { result = RNSSplitViewHostTopColumnForCollapsing::Default; return; }
  if (string == "primary") { result = RNSSplitViewHostTopColumnForCollapsing::Primary; return; }
  if (string == "supplementary") { result = RNSSplitViewHostTopColumnForCollapsing::Supplementary; return; }
  if (string == "secondary") { result = RNSSplitViewHostTopColumnForCollapsing::Secondary; return; }
  abort();
}

static inline std::string toString(const RNSSplitViewHostTopColumnForCollapsing &value) {
  switch (value) {
    case RNSSplitViewHostTopColumnForCollapsing::Default: return "default";
    case RNSSplitViewHostTopColumnForCollapsing::Primary: return "primary";
    case RNSSplitViewHostTopColumnForCollapsing::Supplementary: return "supplementary";
    case RNSSplitViewHostTopColumnForCollapsing::Secondary: return "secondary";
  }
}

#ifdef RN_SERIALIZABLE_STATE
static inline folly::dynamic toDynamic(const RNSSplitViewHostTopColumnForCollapsing &value) {
  return toString(value);
}
#endif
struct RNSSplitViewHostColumnMetricsStruct {
  Float minimumPrimaryColumnWidth{-1.0};
  Float maximumPrimaryColumnWidth{-1.0};
  Float preferredPrimaryColumnWidthOrFraction{-1.0};
  Float minimumSupplementaryColumnWidth{-1.0};
  Float maximumSupplementaryColumnWidth{-1.0};
  Float preferredSupplementaryColumnWidthOrFraction{-1.0};
  Float minimumSecondaryColumnWidth{-1.0};
  Float preferredSecondaryColumnWidthOrFraction{-1.0};
  Float minimumInspectorColumnWidth{-1.0};
  Float maximumInspectorColumnWidth{-1.0};
  Float preferredInspectorColumnWidthOrFraction{-1.0};


#ifdef RN_SERIALIZABLE_STATE
  bool operator==(const RNSSplitViewHostColumnMetricsStruct&) const = default;

  folly::dynamic toDynamic() const {
    folly::dynamic result = folly::dynamic::object();
    result["minimumPrimaryColumnWidth"] = minimumPrimaryColumnWidth;
    result["maximumPrimaryColumnWidth"] = maximumPrimaryColumnWidth;
    result["preferredPrimaryColumnWidthOrFraction"] = preferredPrimaryColumnWidthOrFraction;
    result["minimumSupplementaryColumnWidth"] = minimumSupplementaryColumnWidth;
    result["maximumSupplementaryColumnWidth"] = maximumSupplementaryColumnWidth;
    result["preferredSupplementaryColumnWidthOrFraction"] = preferredSupplementaryColumnWidthOrFraction;
    result["minimumSecondaryColumnWidth"] = minimumSecondaryColumnWidth;
    result["preferredSecondaryColumnWidthOrFraction"] = preferredSecondaryColumnWidthOrFraction;
    result["minimumInspectorColumnWidth"] = minimumInspectorColumnWidth;
    result["maximumInspectorColumnWidth"] = maximumInspectorColumnWidth;
    result["preferredInspectorColumnWidthOrFraction"] = preferredInspectorColumnWidthOrFraction;
    return result;
  }
#endif
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSSplitViewHostColumnMetricsStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_minimumPrimaryColumnWidth = map.find("minimumPrimaryColumnWidth");
  if (tmp_minimumPrimaryColumnWidth != map.end()) {
    fromRawValue(context, tmp_minimumPrimaryColumnWidth->second, result.minimumPrimaryColumnWidth);
  }
  auto tmp_maximumPrimaryColumnWidth = map.find("maximumPrimaryColumnWidth");
  if (tmp_maximumPrimaryColumnWidth != map.end()) {
    fromRawValue(context, tmp_maximumPrimaryColumnWidth->second, result.maximumPrimaryColumnWidth);
  }
  auto tmp_preferredPrimaryColumnWidthOrFraction = map.find("preferredPrimaryColumnWidthOrFraction");
  if (tmp_preferredPrimaryColumnWidthOrFraction != map.end()) {
    fromRawValue(context, tmp_preferredPrimaryColumnWidthOrFraction->second, result.preferredPrimaryColumnWidthOrFraction);
  }
  auto tmp_minimumSupplementaryColumnWidth = map.find("minimumSupplementaryColumnWidth");
  if (tmp_minimumSupplementaryColumnWidth != map.end()) {
    fromRawValue(context, tmp_minimumSupplementaryColumnWidth->second, result.minimumSupplementaryColumnWidth);
  }
  auto tmp_maximumSupplementaryColumnWidth = map.find("maximumSupplementaryColumnWidth");
  if (tmp_maximumSupplementaryColumnWidth != map.end()) {
    fromRawValue(context, tmp_maximumSupplementaryColumnWidth->second, result.maximumSupplementaryColumnWidth);
  }
  auto tmp_preferredSupplementaryColumnWidthOrFraction = map.find("preferredSupplementaryColumnWidthOrFraction");
  if (tmp_preferredSupplementaryColumnWidthOrFraction != map.end()) {
    fromRawValue(context, tmp_preferredSupplementaryColumnWidthOrFraction->second, result.preferredSupplementaryColumnWidthOrFraction);
  }
  auto tmp_minimumSecondaryColumnWidth = map.find("minimumSecondaryColumnWidth");
  if (tmp_minimumSecondaryColumnWidth != map.end()) {
    fromRawValue(context, tmp_minimumSecondaryColumnWidth->second, result.minimumSecondaryColumnWidth);
  }
  auto tmp_preferredSecondaryColumnWidthOrFraction = map.find("preferredSecondaryColumnWidthOrFraction");
  if (tmp_preferredSecondaryColumnWidthOrFraction != map.end()) {
    fromRawValue(context, tmp_preferredSecondaryColumnWidthOrFraction->second, result.preferredSecondaryColumnWidthOrFraction);
  }
  auto tmp_minimumInspectorColumnWidth = map.find("minimumInspectorColumnWidth");
  if (tmp_minimumInspectorColumnWidth != map.end()) {
    fromRawValue(context, tmp_minimumInspectorColumnWidth->second, result.minimumInspectorColumnWidth);
  }
  auto tmp_maximumInspectorColumnWidth = map.find("maximumInspectorColumnWidth");
  if (tmp_maximumInspectorColumnWidth != map.end()) {
    fromRawValue(context, tmp_maximumInspectorColumnWidth->second, result.maximumInspectorColumnWidth);
  }
  auto tmp_preferredInspectorColumnWidthOrFraction = map.find("preferredInspectorColumnWidthOrFraction");
  if (tmp_preferredInspectorColumnWidthOrFraction != map.end()) {
    fromRawValue(context, tmp_preferredInspectorColumnWidthOrFraction->second, result.preferredInspectorColumnWidthOrFraction);
  }
}

static inline std::string toString(const RNSSplitViewHostColumnMetricsStruct &value) {
  return "[Object RNSSplitViewHostColumnMetricsStruct]";
}

#ifdef RN_SERIALIZABLE_STATE
static inline folly::dynamic toDynamic(const RNSSplitViewHostColumnMetricsStruct &value) {
  return value.toDynamic();
}
#endif
class RNSSplitViewHostProps final : public ViewProps {
 public:
  RNSSplitViewHostProps() = default;
  RNSSplitViewHostProps(const PropsParserContext& context, const RNSSplitViewHostProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  RNSSplitViewHostPreferredDisplayMode preferredDisplayMode{RNSSplitViewHostPreferredDisplayMode::Automatic};
  RNSSplitViewHostPreferredSplitBehavior preferredSplitBehavior{RNSSplitViewHostPreferredSplitBehavior::Automatic};
  RNSSplitViewHostPrimaryEdge primaryEdge{RNSSplitViewHostPrimaryEdge::Leading};
  bool showSecondaryToggleButton{false};
  RNSSplitViewHostDisplayModeButtonVisibility displayModeButtonVisibility{RNSSplitViewHostDisplayModeButtonVisibility::Automatic};
  RNSSplitViewHostColumnMetricsStruct columnMetrics{};
  RNSSplitViewHostOrientation orientation{RNSSplitViewHostOrientation::Inherit};
  RNSSplitViewHostPrimaryBackgroundStyle primaryBackgroundStyle{RNSSplitViewHostPrimaryBackgroundStyle::Default};
  RNSSplitViewHostTopColumnForCollapsing topColumnForCollapsing{RNSSplitViewHostTopColumnForCollapsing::Default};
  bool presentsWithGesture{true};
  bool showInspector{false};

  #ifdef RN_SERIALIZABLE_STATE
  ComponentName getDiffPropsImplementationTarget() const override;

  folly::dynamic getDiffProps(const Props* prevProps) const override;
  #endif

  
};

enum class RNSSplitViewScreenColumnType { Column, Inspector };

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSSplitViewScreenColumnType &result) {
  auto string = (std::string)value;
  if (string == "column") { result = RNSSplitViewScreenColumnType::Column; return; }
  if (string == "inspector") { result = RNSSplitViewScreenColumnType::Inspector; return; }
  abort();
}

static inline std::string toString(const RNSSplitViewScreenColumnType &value) {
  switch (value) {
    case RNSSplitViewScreenColumnType::Column: return "column";
    case RNSSplitViewScreenColumnType::Inspector: return "inspector";
  }
}

#ifdef RN_SERIALIZABLE_STATE
static inline folly::dynamic toDynamic(const RNSSplitViewScreenColumnType &value) {
  return toString(value);
}
#endif

class RNSSplitViewScreenProps final : public ViewProps {
 public:
  RNSSplitViewScreenProps() = default;
  RNSSplitViewScreenProps(const PropsParserContext& context, const RNSSplitViewScreenProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  RNSSplitViewScreenColumnType columnType{RNSSplitViewScreenColumnType::Column};

  #ifdef RN_SERIALIZABLE_STATE
  ComponentName getDiffPropsImplementationTarget() const override;

  folly::dynamic getDiffProps(const Props* prevProps) const override;
  #endif

  
};

class RNSStackHostProps final : public ViewProps {
 public:
  RNSStackHostProps() = default;
  RNSStackHostProps(const PropsParserContext& context, const RNSStackHostProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  

  #ifdef RN_SERIALIZABLE_STATE
  ComponentName getDiffPropsImplementationTarget() const override;

  folly::dynamic getDiffProps(const Props* prevProps) const override;
  #endif

  
};

enum class RNSStackScreenActivityMode { Detached, Attached };

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSStackScreenActivityMode &result) {
  auto string = (std::string)value;
  if (string == "detached") { result = RNSStackScreenActivityMode::Detached; return; }
  if (string == "attached") { result = RNSStackScreenActivityMode::Attached; return; }
  abort();
}

static inline std::string toString(const RNSStackScreenActivityMode &value) {
  switch (value) {
    case RNSStackScreenActivityMode::Detached: return "detached";
    case RNSStackScreenActivityMode::Attached: return "attached";
  }
}

#ifdef RN_SERIALIZABLE_STATE
static inline folly::dynamic toDynamic(const RNSStackScreenActivityMode &value) {
  return toString(value);
}
#endif

class RNSStackScreenProps final : public ViewProps {
 public:
  RNSStackScreenProps() = default;
  RNSStackScreenProps(const PropsParserContext& context, const RNSStackScreenProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  RNSStackScreenActivityMode activityMode{RNSStackScreenActivityMode::Detached};
  std::string screenKey{};
  bool preventNativeDismiss{false};

  #ifdef RN_SERIALIZABLE_STATE
  ComponentName getDiffPropsImplementationTarget() const override;

  folly::dynamic getDiffProps(const Props* prevProps) const override;
  #endif

  
};

enum class RNSModalScreenFullScreenSwipeEnabled { Undefined, False, True };

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSModalScreenFullScreenSwipeEnabled &result) {
  auto string = (std::string)value;
  if (string == "undefined") { result = RNSModalScreenFullScreenSwipeEnabled::Undefined; return; }
  if (string == "false") { result = RNSModalScreenFullScreenSwipeEnabled::False; return; }
  if (string == "true") { result = RNSModalScreenFullScreenSwipeEnabled::True; return; }
  abort();
}

static inline std::string toString(const RNSModalScreenFullScreenSwipeEnabled &value) {
  switch (value) {
    case RNSModalScreenFullScreenSwipeEnabled::Undefined: return "undefined";
    case RNSModalScreenFullScreenSwipeEnabled::False: return "false";
    case RNSModalScreenFullScreenSwipeEnabled::True: return "true";
  }
}

#ifdef RN_SERIALIZABLE_STATE
static inline folly::dynamic toDynamic(const RNSModalScreenFullScreenSwipeEnabled &value) {
  return toString(value);
}
#endif
enum class RNSModalScreenStackPresentation { Push, Modal, TransparentModal, FullScreenModal, FormSheet, PageSheet, ContainedModal, ContainedTransparentModal };

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSModalScreenStackPresentation &result) {
  auto string = (std::string)value;
  if (string == "push") { result = RNSModalScreenStackPresentation::Push; return; }
  if (string == "modal") { result = RNSModalScreenStackPresentation::Modal; return; }
  if (string == "transparentModal") { result = RNSModalScreenStackPresentation::TransparentModal; return; }
  if (string == "fullScreenModal") { result = RNSModalScreenStackPresentation::FullScreenModal; return; }
  if (string == "formSheet") { result = RNSModalScreenStackPresentation::FormSheet; return; }
  if (string == "pageSheet") { result = RNSModalScreenStackPresentation::PageSheet; return; }
  if (string == "containedModal") { result = RNSModalScreenStackPresentation::ContainedModal; return; }
  if (string == "containedTransparentModal") { result = RNSModalScreenStackPresentation::ContainedTransparentModal; return; }
  abort();
}

static inline std::string toString(const RNSModalScreenStackPresentation &value) {
  switch (value) {
    case RNSModalScreenStackPresentation::Push: return "push";
    case RNSModalScreenStackPresentation::Modal: return "modal";
    case RNSModalScreenStackPresentation::TransparentModal: return "transparentModal";
    case RNSModalScreenStackPresentation::FullScreenModal: return "fullScreenModal";
    case RNSModalScreenStackPresentation::FormSheet: return "formSheet";
    case RNSModalScreenStackPresentation::PageSheet: return "pageSheet";
    case RNSModalScreenStackPresentation::ContainedModal: return "containedModal";
    case RNSModalScreenStackPresentation::ContainedTransparentModal: return "containedTransparentModal";
  }
}

#ifdef RN_SERIALIZABLE_STATE
static inline folly::dynamic toDynamic(const RNSModalScreenStackPresentation &value) {
  return toString(value);
}
#endif
enum class RNSModalScreenStackAnimation { Default, Flip, Simple_push, None, Fade, Slide_from_right, Slide_from_left, Slide_from_bottom, Fade_from_bottom, Ios_from_right, Ios_from_left };

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSModalScreenStackAnimation &result) {
  auto string = (std::string)value;
  if (string == "default") { result = RNSModalScreenStackAnimation::Default; return; }
  if (string == "flip") { result = RNSModalScreenStackAnimation::Flip; return; }
  if (string == "simple_push") { result = RNSModalScreenStackAnimation::Simple_push; return; }
  if (string == "none") { result = RNSModalScreenStackAnimation::None; return; }
  if (string == "fade") { result = RNSModalScreenStackAnimation::Fade; return; }
  if (string == "slide_from_right") { result = RNSModalScreenStackAnimation::Slide_from_right; return; }
  if (string == "slide_from_left") { result = RNSModalScreenStackAnimation::Slide_from_left; return; }
  if (string == "slide_from_bottom") { result = RNSModalScreenStackAnimation::Slide_from_bottom; return; }
  if (string == "fade_from_bottom") { result = RNSModalScreenStackAnimation::Fade_from_bottom; return; }
  if (string == "ios_from_right") { result = RNSModalScreenStackAnimation::Ios_from_right; return; }
  if (string == "ios_from_left") { result = RNSModalScreenStackAnimation::Ios_from_left; return; }
  abort();
}

static inline std::string toString(const RNSModalScreenStackAnimation &value) {
  switch (value) {
    case RNSModalScreenStackAnimation::Default: return "default";
    case RNSModalScreenStackAnimation::Flip: return "flip";
    case RNSModalScreenStackAnimation::Simple_push: return "simple_push";
    case RNSModalScreenStackAnimation::None: return "none";
    case RNSModalScreenStackAnimation::Fade: return "fade";
    case RNSModalScreenStackAnimation::Slide_from_right: return "slide_from_right";
    case RNSModalScreenStackAnimation::Slide_from_left: return "slide_from_left";
    case RNSModalScreenStackAnimation::Slide_from_bottom: return "slide_from_bottom";
    case RNSModalScreenStackAnimation::Fade_from_bottom: return "fade_from_bottom";
    case RNSModalScreenStackAnimation::Ios_from_right: return "ios_from_right";
    case RNSModalScreenStackAnimation::Ios_from_left: return "ios_from_left";
  }
}

#ifdef RN_SERIALIZABLE_STATE
static inline folly::dynamic toDynamic(const RNSModalScreenStackAnimation &value) {
  return toString(value);
}
#endif
enum class RNSModalScreenReplaceAnimation { Pop, Push };

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSModalScreenReplaceAnimation &result) {
  auto string = (std::string)value;
  if (string == "pop") { result = RNSModalScreenReplaceAnimation::Pop; return; }
  if (string == "push") { result = RNSModalScreenReplaceAnimation::Push; return; }
  abort();
}

static inline std::string toString(const RNSModalScreenReplaceAnimation &value) {
  switch (value) {
    case RNSModalScreenReplaceAnimation::Pop: return "pop";
    case RNSModalScreenReplaceAnimation::Push: return "push";
  }
}

#ifdef RN_SERIALIZABLE_STATE
static inline folly::dynamic toDynamic(const RNSModalScreenReplaceAnimation &value) {
  return toString(value);
}
#endif
enum class RNSModalScreenSwipeDirection { Vertical, Horizontal };

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSModalScreenSwipeDirection &result) {
  auto string = (std::string)value;
  if (string == "vertical") { result = RNSModalScreenSwipeDirection::Vertical; return; }
  if (string == "horizontal") { result = RNSModalScreenSwipeDirection::Horizontal; return; }
  abort();
}

static inline std::string toString(const RNSModalScreenSwipeDirection &value) {
  switch (value) {
    case RNSModalScreenSwipeDirection::Vertical: return "vertical";
    case RNSModalScreenSwipeDirection::Horizontal: return "horizontal";
  }
}

#ifdef RN_SERIALIZABLE_STATE
static inline folly::dynamic toDynamic(const RNSModalScreenSwipeDirection &value) {
  return toString(value);
}
#endif
struct RNSModalScreenGestureResponseDistanceStruct {
  Float start{0.0};
  Float end{0.0};
  Float top{0.0};
  Float bottom{0.0};


#ifdef RN_SERIALIZABLE_STATE
  bool operator==(const RNSModalScreenGestureResponseDistanceStruct&) const = default;

  folly::dynamic toDynamic() const {
    folly::dynamic result = folly::dynamic::object();
    result["start"] = start;
    result["end"] = end;
    result["top"] = top;
    result["bottom"] = bottom;
    return result;
  }
#endif
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSModalScreenGestureResponseDistanceStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_start = map.find("start");
  if (tmp_start != map.end()) {
    fromRawValue(context, tmp_start->second, result.start);
  }
  auto tmp_end = map.find("end");
  if (tmp_end != map.end()) {
    fromRawValue(context, tmp_end->second, result.end);
  }
  auto tmp_top = map.find("top");
  if (tmp_top != map.end()) {
    fromRawValue(context, tmp_top->second, result.top);
  }
  auto tmp_bottom = map.find("bottom");
  if (tmp_bottom != map.end()) {
    fromRawValue(context, tmp_bottom->second, result.bottom);
  }
}

static inline std::string toString(const RNSModalScreenGestureResponseDistanceStruct &value) {
  return "[Object RNSModalScreenGestureResponseDistanceStruct]";
}

#ifdef RN_SERIALIZABLE_STATE
static inline folly::dynamic toDynamic(const RNSModalScreenGestureResponseDistanceStruct &value) {
  return value.toDynamic();
}
#endif
class RNSModalScreenProps final : public ViewProps {
 public:
  RNSModalScreenProps() = default;
  RNSModalScreenProps(const PropsParserContext& context, const RNSModalScreenProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  std::string screenId{std::string{""}};
  std::vector<Float> sheetAllowedDetents{};
  int sheetLargestUndimmedDetent{-1};
  bool sheetGrabberVisible{false};
  Float sheetCornerRadius{-1.0};
  bool sheetExpandsWhenScrolledToEdge{false};
  int sheetInitialDetent{0};
  int sheetElevation{24};
  bool sheetShouldOverflowTopInset{false};
  bool sheetDefaultResizeAnimationEnabled{true};
  bool customAnimationOnSwipe{false};
  RNSModalScreenFullScreenSwipeEnabled fullScreenSwipeEnabled{RNSModalScreenFullScreenSwipeEnabled::Undefined};
  bool fullScreenSwipeShadowEnabled{true};
  bool homeIndicatorHidden{false};
  bool preventNativeDismiss{false};
  bool gestureEnabled{true};
  SharedColor statusBarColor{};
  bool statusBarHidden{false};
  std::string screenOrientation{};
  std::string statusBarAnimation{};
  std::string statusBarStyle{};
  bool statusBarTranslucent{false};
  RNSModalScreenGestureResponseDistanceStruct gestureResponseDistance{};
  RNSModalScreenStackPresentation stackPresentation{RNSModalScreenStackPresentation::Push};
  RNSModalScreenStackAnimation stackAnimation{RNSModalScreenStackAnimation::Default};
  int transitionDuration{500};
  RNSModalScreenReplaceAnimation replaceAnimation{RNSModalScreenReplaceAnimation::Pop};
  RNSModalScreenSwipeDirection swipeDirection{RNSModalScreenSwipeDirection::Horizontal};
  bool hideKeyboardOnSwipe{false};
  Float activityState{-1.0};
  SharedColor navigationBarColor{};
  bool navigationBarTranslucent{false};
  bool navigationBarHidden{false};
  bool nativeBackButtonDismissalEnabled{false};
  bool synchronousShadowStateUpdatesEnabled{false};

  #ifdef RN_SERIALIZABLE_STATE
  ComponentName getDiffPropsImplementationTarget() const override;

  folly::dynamic getDiffProps(const Props* prevProps) const override;
  #endif

  
};

enum class RNSSafeAreaViewInsetType { All, System, Interface };

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSSafeAreaViewInsetType &result) {
  auto string = (std::string)value;
  if (string == "all") { result = RNSSafeAreaViewInsetType::All; return; }
  if (string == "system") { result = RNSSafeAreaViewInsetType::System; return; }
  if (string == "interface") { result = RNSSafeAreaViewInsetType::Interface; return; }
  abort();
}

static inline std::string toString(const RNSSafeAreaViewInsetType &value) {
  switch (value) {
    case RNSSafeAreaViewInsetType::All: return "all";
    case RNSSafeAreaViewInsetType::System: return "system";
    case RNSSafeAreaViewInsetType::Interface: return "interface";
  }
}

#ifdef RN_SERIALIZABLE_STATE
static inline folly::dynamic toDynamic(const RNSSafeAreaViewInsetType &value) {
  return toString(value);
}
#endif
struct RNSSafeAreaViewEdgesStruct {
  bool top{false};
  bool right{false};
  bool bottom{false};
  bool left{false};


#ifdef RN_SERIALIZABLE_STATE
  bool operator==(const RNSSafeAreaViewEdgesStruct&) const = default;

  folly::dynamic toDynamic() const {
    folly::dynamic result = folly::dynamic::object();
    result["top"] = top;
    result["right"] = right;
    result["bottom"] = bottom;
    result["left"] = left;
    return result;
  }
#endif
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSSafeAreaViewEdgesStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_top = map.find("top");
  if (tmp_top != map.end()) {
    fromRawValue(context, tmp_top->second, result.top);
  }
  auto tmp_right = map.find("right");
  if (tmp_right != map.end()) {
    fromRawValue(context, tmp_right->second, result.right);
  }
  auto tmp_bottom = map.find("bottom");
  if (tmp_bottom != map.end()) {
    fromRawValue(context, tmp_bottom->second, result.bottom);
  }
  auto tmp_left = map.find("left");
  if (tmp_left != map.end()) {
    fromRawValue(context, tmp_left->second, result.left);
  }
}

static inline std::string toString(const RNSSafeAreaViewEdgesStruct &value) {
  return "[Object RNSSafeAreaViewEdgesStruct]";
}

#ifdef RN_SERIALIZABLE_STATE
static inline folly::dynamic toDynamic(const RNSSafeAreaViewEdgesStruct &value) {
  return value.toDynamic();
}
#endif
class RNSSafeAreaViewProps final : public ViewProps {
 public:
  RNSSafeAreaViewProps() = default;
  RNSSafeAreaViewProps(const PropsParserContext& context, const RNSSafeAreaViewProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  RNSSafeAreaViewEdgesStruct edges{};
  RNSSafeAreaViewInsetType insetType{RNSSafeAreaViewInsetType::All};

  #ifdef RN_SERIALIZABLE_STATE
  ComponentName getDiffPropsImplementationTarget() const override;

  folly::dynamic getDiffProps(const Props* prevProps) const override;
  #endif

  
};

class RNSScreenContainerProps final : public ViewProps {
 public:
  RNSScreenContainerProps() = default;
  RNSScreenContainerProps(const PropsParserContext& context, const RNSScreenContainerProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  

  #ifdef RN_SERIALIZABLE_STATE
  ComponentName getDiffPropsImplementationTarget() const override;

  folly::dynamic getDiffProps(const Props* prevProps) const override;
  #endif

  
};

class RNSScreenContentWrapperProps final : public ViewProps {
 public:
  RNSScreenContentWrapperProps() = default;
  RNSScreenContentWrapperProps(const PropsParserContext& context, const RNSScreenContentWrapperProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  

  #ifdef RN_SERIALIZABLE_STATE
  ComponentName getDiffPropsImplementationTarget() const override;

  folly::dynamic getDiffProps(const Props* prevProps) const override;
  #endif

  
};

class RNSScreenFooterProps final : public ViewProps {
 public:
  RNSScreenFooterProps() = default;
  RNSScreenFooterProps(const PropsParserContext& context, const RNSScreenFooterProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  

  #ifdef RN_SERIALIZABLE_STATE
  ComponentName getDiffPropsImplementationTarget() const override;

  folly::dynamic getDiffProps(const Props* prevProps) const override;
  #endif

  
};

enum class RNSScreenFullScreenSwipeEnabled { Undefined, False, True };

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSScreenFullScreenSwipeEnabled &result) {
  auto string = (std::string)value;
  if (string == "undefined") { result = RNSScreenFullScreenSwipeEnabled::Undefined; return; }
  if (string == "false") { result = RNSScreenFullScreenSwipeEnabled::False; return; }
  if (string == "true") { result = RNSScreenFullScreenSwipeEnabled::True; return; }
  abort();
}

static inline std::string toString(const RNSScreenFullScreenSwipeEnabled &value) {
  switch (value) {
    case RNSScreenFullScreenSwipeEnabled::Undefined: return "undefined";
    case RNSScreenFullScreenSwipeEnabled::False: return "false";
    case RNSScreenFullScreenSwipeEnabled::True: return "true";
  }
}

#ifdef RN_SERIALIZABLE_STATE
static inline folly::dynamic toDynamic(const RNSScreenFullScreenSwipeEnabled &value) {
  return toString(value);
}
#endif
enum class RNSScreenStackPresentation { Push, Modal, TransparentModal, FullScreenModal, FormSheet, PageSheet, ContainedModal, ContainedTransparentModal };

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSScreenStackPresentation &result) {
  auto string = (std::string)value;
  if (string == "push") { result = RNSScreenStackPresentation::Push; return; }
  if (string == "modal") { result = RNSScreenStackPresentation::Modal; return; }
  if (string == "transparentModal") { result = RNSScreenStackPresentation::TransparentModal; return; }
  if (string == "fullScreenModal") { result = RNSScreenStackPresentation::FullScreenModal; return; }
  if (string == "formSheet") { result = RNSScreenStackPresentation::FormSheet; return; }
  if (string == "pageSheet") { result = RNSScreenStackPresentation::PageSheet; return; }
  if (string == "containedModal") { result = RNSScreenStackPresentation::ContainedModal; return; }
  if (string == "containedTransparentModal") { result = RNSScreenStackPresentation::ContainedTransparentModal; return; }
  abort();
}

static inline std::string toString(const RNSScreenStackPresentation &value) {
  switch (value) {
    case RNSScreenStackPresentation::Push: return "push";
    case RNSScreenStackPresentation::Modal: return "modal";
    case RNSScreenStackPresentation::TransparentModal: return "transparentModal";
    case RNSScreenStackPresentation::FullScreenModal: return "fullScreenModal";
    case RNSScreenStackPresentation::FormSheet: return "formSheet";
    case RNSScreenStackPresentation::PageSheet: return "pageSheet";
    case RNSScreenStackPresentation::ContainedModal: return "containedModal";
    case RNSScreenStackPresentation::ContainedTransparentModal: return "containedTransparentModal";
  }
}

#ifdef RN_SERIALIZABLE_STATE
static inline folly::dynamic toDynamic(const RNSScreenStackPresentation &value) {
  return toString(value);
}
#endif
enum class RNSScreenStackAnimation { Default, Flip, Simple_push, None, Fade, Slide_from_right, Slide_from_left, Slide_from_bottom, Fade_from_bottom, Ios_from_right, Ios_from_left };

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSScreenStackAnimation &result) {
  auto string = (std::string)value;
  if (string == "default") { result = RNSScreenStackAnimation::Default; return; }
  if (string == "flip") { result = RNSScreenStackAnimation::Flip; return; }
  if (string == "simple_push") { result = RNSScreenStackAnimation::Simple_push; return; }
  if (string == "none") { result = RNSScreenStackAnimation::None; return; }
  if (string == "fade") { result = RNSScreenStackAnimation::Fade; return; }
  if (string == "slide_from_right") { result = RNSScreenStackAnimation::Slide_from_right; return; }
  if (string == "slide_from_left") { result = RNSScreenStackAnimation::Slide_from_left; return; }
  if (string == "slide_from_bottom") { result = RNSScreenStackAnimation::Slide_from_bottom; return; }
  if (string == "fade_from_bottom") { result = RNSScreenStackAnimation::Fade_from_bottom; return; }
  if (string == "ios_from_right") { result = RNSScreenStackAnimation::Ios_from_right; return; }
  if (string == "ios_from_left") { result = RNSScreenStackAnimation::Ios_from_left; return; }
  abort();
}

static inline std::string toString(const RNSScreenStackAnimation &value) {
  switch (value) {
    case RNSScreenStackAnimation::Default: return "default";
    case RNSScreenStackAnimation::Flip: return "flip";
    case RNSScreenStackAnimation::Simple_push: return "simple_push";
    case RNSScreenStackAnimation::None: return "none";
    case RNSScreenStackAnimation::Fade: return "fade";
    case RNSScreenStackAnimation::Slide_from_right: return "slide_from_right";
    case RNSScreenStackAnimation::Slide_from_left: return "slide_from_left";
    case RNSScreenStackAnimation::Slide_from_bottom: return "slide_from_bottom";
    case RNSScreenStackAnimation::Fade_from_bottom: return "fade_from_bottom";
    case RNSScreenStackAnimation::Ios_from_right: return "ios_from_right";
    case RNSScreenStackAnimation::Ios_from_left: return "ios_from_left";
  }
}

#ifdef RN_SERIALIZABLE_STATE
static inline folly::dynamic toDynamic(const RNSScreenStackAnimation &value) {
  return toString(value);
}
#endif
enum class RNSScreenReplaceAnimation { Pop, Push };

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSScreenReplaceAnimation &result) {
  auto string = (std::string)value;
  if (string == "pop") { result = RNSScreenReplaceAnimation::Pop; return; }
  if (string == "push") { result = RNSScreenReplaceAnimation::Push; return; }
  abort();
}

static inline std::string toString(const RNSScreenReplaceAnimation &value) {
  switch (value) {
    case RNSScreenReplaceAnimation::Pop: return "pop";
    case RNSScreenReplaceAnimation::Push: return "push";
  }
}

#ifdef RN_SERIALIZABLE_STATE
static inline folly::dynamic toDynamic(const RNSScreenReplaceAnimation &value) {
  return toString(value);
}
#endif
enum class RNSScreenSwipeDirection { Vertical, Horizontal };

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSScreenSwipeDirection &result) {
  auto string = (std::string)value;
  if (string == "vertical") { result = RNSScreenSwipeDirection::Vertical; return; }
  if (string == "horizontal") { result = RNSScreenSwipeDirection::Horizontal; return; }
  abort();
}

static inline std::string toString(const RNSScreenSwipeDirection &value) {
  switch (value) {
    case RNSScreenSwipeDirection::Vertical: return "vertical";
    case RNSScreenSwipeDirection::Horizontal: return "horizontal";
  }
}

#ifdef RN_SERIALIZABLE_STATE
static inline folly::dynamic toDynamic(const RNSScreenSwipeDirection &value) {
  return toString(value);
}
#endif
enum class RNSScreenBottomScrollEdgeEffect { Automatic, Hard, Soft, Hidden };

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSScreenBottomScrollEdgeEffect &result) {
  auto string = (std::string)value;
  if (string == "automatic") { result = RNSScreenBottomScrollEdgeEffect::Automatic; return; }
  if (string == "hard") { result = RNSScreenBottomScrollEdgeEffect::Hard; return; }
  if (string == "soft") { result = RNSScreenBottomScrollEdgeEffect::Soft; return; }
  if (string == "hidden") { result = RNSScreenBottomScrollEdgeEffect::Hidden; return; }
  abort();
}

static inline std::string toString(const RNSScreenBottomScrollEdgeEffect &value) {
  switch (value) {
    case RNSScreenBottomScrollEdgeEffect::Automatic: return "automatic";
    case RNSScreenBottomScrollEdgeEffect::Hard: return "hard";
    case RNSScreenBottomScrollEdgeEffect::Soft: return "soft";
    case RNSScreenBottomScrollEdgeEffect::Hidden: return "hidden";
  }
}

#ifdef RN_SERIALIZABLE_STATE
static inline folly::dynamic toDynamic(const RNSScreenBottomScrollEdgeEffect &value) {
  return toString(value);
}
#endif
enum class RNSScreenLeftScrollEdgeEffect { Automatic, Hard, Soft, Hidden };

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSScreenLeftScrollEdgeEffect &result) {
  auto string = (std::string)value;
  if (string == "automatic") { result = RNSScreenLeftScrollEdgeEffect::Automatic; return; }
  if (string == "hard") { result = RNSScreenLeftScrollEdgeEffect::Hard; return; }
  if (string == "soft") { result = RNSScreenLeftScrollEdgeEffect::Soft; return; }
  if (string == "hidden") { result = RNSScreenLeftScrollEdgeEffect::Hidden; return; }
  abort();
}

static inline std::string toString(const RNSScreenLeftScrollEdgeEffect &value) {
  switch (value) {
    case RNSScreenLeftScrollEdgeEffect::Automatic: return "automatic";
    case RNSScreenLeftScrollEdgeEffect::Hard: return "hard";
    case RNSScreenLeftScrollEdgeEffect::Soft: return "soft";
    case RNSScreenLeftScrollEdgeEffect::Hidden: return "hidden";
  }
}

#ifdef RN_SERIALIZABLE_STATE
static inline folly::dynamic toDynamic(const RNSScreenLeftScrollEdgeEffect &value) {
  return toString(value);
}
#endif
enum class RNSScreenRightScrollEdgeEffect { Automatic, Hard, Soft, Hidden };

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSScreenRightScrollEdgeEffect &result) {
  auto string = (std::string)value;
  if (string == "automatic") { result = RNSScreenRightScrollEdgeEffect::Automatic; return; }
  if (string == "hard") { result = RNSScreenRightScrollEdgeEffect::Hard; return; }
  if (string == "soft") { result = RNSScreenRightScrollEdgeEffect::Soft; return; }
  if (string == "hidden") { result = RNSScreenRightScrollEdgeEffect::Hidden; return; }
  abort();
}

static inline std::string toString(const RNSScreenRightScrollEdgeEffect &value) {
  switch (value) {
    case RNSScreenRightScrollEdgeEffect::Automatic: return "automatic";
    case RNSScreenRightScrollEdgeEffect::Hard: return "hard";
    case RNSScreenRightScrollEdgeEffect::Soft: return "soft";
    case RNSScreenRightScrollEdgeEffect::Hidden: return "hidden";
  }
}

#ifdef RN_SERIALIZABLE_STATE
static inline folly::dynamic toDynamic(const RNSScreenRightScrollEdgeEffect &value) {
  return toString(value);
}
#endif
enum class RNSScreenTopScrollEdgeEffect { Automatic, Hard, Soft, Hidden };

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSScreenTopScrollEdgeEffect &result) {
  auto string = (std::string)value;
  if (string == "automatic") { result = RNSScreenTopScrollEdgeEffect::Automatic; return; }
  if (string == "hard") { result = RNSScreenTopScrollEdgeEffect::Hard; return; }
  if (string == "soft") { result = RNSScreenTopScrollEdgeEffect::Soft; return; }
  if (string == "hidden") { result = RNSScreenTopScrollEdgeEffect::Hidden; return; }
  abort();
}

static inline std::string toString(const RNSScreenTopScrollEdgeEffect &value) {
  switch (value) {
    case RNSScreenTopScrollEdgeEffect::Automatic: return "automatic";
    case RNSScreenTopScrollEdgeEffect::Hard: return "hard";
    case RNSScreenTopScrollEdgeEffect::Soft: return "soft";
    case RNSScreenTopScrollEdgeEffect::Hidden: return "hidden";
  }
}

#ifdef RN_SERIALIZABLE_STATE
static inline folly::dynamic toDynamic(const RNSScreenTopScrollEdgeEffect &value) {
  return toString(value);
}
#endif
struct RNSScreenGestureResponseDistanceStruct {
  Float start{0.0};
  Float end{0.0};
  Float top{0.0};
  Float bottom{0.0};


#ifdef RN_SERIALIZABLE_STATE
  bool operator==(const RNSScreenGestureResponseDistanceStruct&) const = default;

  folly::dynamic toDynamic() const {
    folly::dynamic result = folly::dynamic::object();
    result["start"] = start;
    result["end"] = end;
    result["top"] = top;
    result["bottom"] = bottom;
    return result;
  }
#endif
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSScreenGestureResponseDistanceStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_start = map.find("start");
  if (tmp_start != map.end()) {
    fromRawValue(context, tmp_start->second, result.start);
  }
  auto tmp_end = map.find("end");
  if (tmp_end != map.end()) {
    fromRawValue(context, tmp_end->second, result.end);
  }
  auto tmp_top = map.find("top");
  if (tmp_top != map.end()) {
    fromRawValue(context, tmp_top->second, result.top);
  }
  auto tmp_bottom = map.find("bottom");
  if (tmp_bottom != map.end()) {
    fromRawValue(context, tmp_bottom->second, result.bottom);
  }
}

static inline std::string toString(const RNSScreenGestureResponseDistanceStruct &value) {
  return "[Object RNSScreenGestureResponseDistanceStruct]";
}

#ifdef RN_SERIALIZABLE_STATE
static inline folly::dynamic toDynamic(const RNSScreenGestureResponseDistanceStruct &value) {
  return value.toDynamic();
}
#endif
class RNSScreenProps final : public ViewProps {
 public:
  RNSScreenProps() = default;
  RNSScreenProps(const PropsParserContext& context, const RNSScreenProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  std::string screenId{std::string{""}};
  std::vector<Float> sheetAllowedDetents{};
  int sheetLargestUndimmedDetent{-1};
  bool sheetGrabberVisible{false};
  Float sheetCornerRadius{-1.0};
  bool sheetExpandsWhenScrolledToEdge{false};
  int sheetInitialDetent{0};
  int sheetElevation{24};
  bool sheetShouldOverflowTopInset{false};
  bool sheetDefaultResizeAnimationEnabled{true};
  bool customAnimationOnSwipe{false};
  RNSScreenFullScreenSwipeEnabled fullScreenSwipeEnabled{RNSScreenFullScreenSwipeEnabled::Undefined};
  bool fullScreenSwipeShadowEnabled{true};
  bool homeIndicatorHidden{false};
  bool preventNativeDismiss{false};
  bool gestureEnabled{true};
  SharedColor statusBarColor{};
  bool statusBarHidden{false};
  std::string screenOrientation{};
  std::string statusBarAnimation{};
  std::string statusBarStyle{};
  bool statusBarTranslucent{false};
  RNSScreenGestureResponseDistanceStruct gestureResponseDistance{};
  RNSScreenStackPresentation stackPresentation{RNSScreenStackPresentation::Push};
  RNSScreenStackAnimation stackAnimation{RNSScreenStackAnimation::Default};
  int transitionDuration{500};
  RNSScreenReplaceAnimation replaceAnimation{RNSScreenReplaceAnimation::Pop};
  RNSScreenSwipeDirection swipeDirection{RNSScreenSwipeDirection::Horizontal};
  bool hideKeyboardOnSwipe{false};
  Float activityState{-1.0};
  SharedColor navigationBarColor{};
  bool navigationBarTranslucent{false};
  bool navigationBarHidden{false};
  bool nativeBackButtonDismissalEnabled{false};
  RNSScreenBottomScrollEdgeEffect bottomScrollEdgeEffect{RNSScreenBottomScrollEdgeEffect::Automatic};
  RNSScreenLeftScrollEdgeEffect leftScrollEdgeEffect{RNSScreenLeftScrollEdgeEffect::Automatic};
  RNSScreenRightScrollEdgeEffect rightScrollEdgeEffect{RNSScreenRightScrollEdgeEffect::Automatic};
  RNSScreenTopScrollEdgeEffect topScrollEdgeEffect{RNSScreenTopScrollEdgeEffect::Automatic};
  bool synchronousShadowStateUpdatesEnabled{false};
  bool androidResetScreenShadowStateOnOrientationChangeEnabled{true};
  bool ios26AllowInteractionsDuringTransition{true};

  #ifdef RN_SERIALIZABLE_STATE
  ComponentName getDiffPropsImplementationTarget() const override;

  folly::dynamic getDiffProps(const Props* prevProps) const override;
  #endif

  
};

class RNSScreenNavigationContainerProps final : public ViewProps {
 public:
  RNSScreenNavigationContainerProps() = default;
  RNSScreenNavigationContainerProps(const PropsParserContext& context, const RNSScreenNavigationContainerProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  

  #ifdef RN_SERIALIZABLE_STATE
  ComponentName getDiffPropsImplementationTarget() const override;

  folly::dynamic getDiffProps(const Props* prevProps) const override;
  #endif

  
};

enum class RNSScreenStackHeaderConfigDirection { Rtl, Ltr };

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSScreenStackHeaderConfigDirection &result) {
  auto string = (std::string)value;
  if (string == "rtl") { result = RNSScreenStackHeaderConfigDirection::Rtl; return; }
  if (string == "ltr") { result = RNSScreenStackHeaderConfigDirection::Ltr; return; }
  abort();
}

static inline std::string toString(const RNSScreenStackHeaderConfigDirection &value) {
  switch (value) {
    case RNSScreenStackHeaderConfigDirection::Rtl: return "rtl";
    case RNSScreenStackHeaderConfigDirection::Ltr: return "ltr";
  }
}

#ifdef RN_SERIALIZABLE_STATE
static inline folly::dynamic toDynamic(const RNSScreenStackHeaderConfigDirection &value) {
  return toString(value);
}
#endif
enum class RNSScreenStackHeaderConfigBackButtonDisplayMode { Minimal, Default, Generic };

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSScreenStackHeaderConfigBackButtonDisplayMode &result) {
  auto string = (std::string)value;
  if (string == "minimal") { result = RNSScreenStackHeaderConfigBackButtonDisplayMode::Minimal; return; }
  if (string == "default") { result = RNSScreenStackHeaderConfigBackButtonDisplayMode::Default; return; }
  if (string == "generic") { result = RNSScreenStackHeaderConfigBackButtonDisplayMode::Generic; return; }
  abort();
}

static inline std::string toString(const RNSScreenStackHeaderConfigBackButtonDisplayMode &value) {
  switch (value) {
    case RNSScreenStackHeaderConfigBackButtonDisplayMode::Minimal: return "minimal";
    case RNSScreenStackHeaderConfigBackButtonDisplayMode::Default: return "default";
    case RNSScreenStackHeaderConfigBackButtonDisplayMode::Generic: return "generic";
  }
}

#ifdef RN_SERIALIZABLE_STATE
static inline folly::dynamic toDynamic(const RNSScreenStackHeaderConfigBackButtonDisplayMode &value) {
  return toString(value);
}
#endif
enum class RNSScreenStackHeaderConfigBlurEffect { None, ExtraLight, Light, Dark, Regular, Prominent, SystemUltraThinMaterial, SystemThinMaterial, SystemMaterial, SystemThickMaterial, SystemChromeMaterial, SystemUltraThinMaterialLight, SystemThinMaterialLight, SystemMaterialLight, SystemThickMaterialLight, SystemChromeMaterialLight, SystemUltraThinMaterialDark, SystemThinMaterialDark, SystemMaterialDark, SystemThickMaterialDark, SystemChromeMaterialDark };

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSScreenStackHeaderConfigBlurEffect &result) {
  auto string = (std::string)value;
  if (string == "none") { result = RNSScreenStackHeaderConfigBlurEffect::None; return; }
  if (string == "extraLight") { result = RNSScreenStackHeaderConfigBlurEffect::ExtraLight; return; }
  if (string == "light") { result = RNSScreenStackHeaderConfigBlurEffect::Light; return; }
  if (string == "dark") { result = RNSScreenStackHeaderConfigBlurEffect::Dark; return; }
  if (string == "regular") { result = RNSScreenStackHeaderConfigBlurEffect::Regular; return; }
  if (string == "prominent") { result = RNSScreenStackHeaderConfigBlurEffect::Prominent; return; }
  if (string == "systemUltraThinMaterial") { result = RNSScreenStackHeaderConfigBlurEffect::SystemUltraThinMaterial; return; }
  if (string == "systemThinMaterial") { result = RNSScreenStackHeaderConfigBlurEffect::SystemThinMaterial; return; }
  if (string == "systemMaterial") { result = RNSScreenStackHeaderConfigBlurEffect::SystemMaterial; return; }
  if (string == "systemThickMaterial") { result = RNSScreenStackHeaderConfigBlurEffect::SystemThickMaterial; return; }
  if (string == "systemChromeMaterial") { result = RNSScreenStackHeaderConfigBlurEffect::SystemChromeMaterial; return; }
  if (string == "systemUltraThinMaterialLight") { result = RNSScreenStackHeaderConfigBlurEffect::SystemUltraThinMaterialLight; return; }
  if (string == "systemThinMaterialLight") { result = RNSScreenStackHeaderConfigBlurEffect::SystemThinMaterialLight; return; }
  if (string == "systemMaterialLight") { result = RNSScreenStackHeaderConfigBlurEffect::SystemMaterialLight; return; }
  if (string == "systemThickMaterialLight") { result = RNSScreenStackHeaderConfigBlurEffect::SystemThickMaterialLight; return; }
  if (string == "systemChromeMaterialLight") { result = RNSScreenStackHeaderConfigBlurEffect::SystemChromeMaterialLight; return; }
  if (string == "systemUltraThinMaterialDark") { result = RNSScreenStackHeaderConfigBlurEffect::SystemUltraThinMaterialDark; return; }
  if (string == "systemThinMaterialDark") { result = RNSScreenStackHeaderConfigBlurEffect::SystemThinMaterialDark; return; }
  if (string == "systemMaterialDark") { result = RNSScreenStackHeaderConfigBlurEffect::SystemMaterialDark; return; }
  if (string == "systemThickMaterialDark") { result = RNSScreenStackHeaderConfigBlurEffect::SystemThickMaterialDark; return; }
  if (string == "systemChromeMaterialDark") { result = RNSScreenStackHeaderConfigBlurEffect::SystemChromeMaterialDark; return; }
  abort();
}

static inline std::string toString(const RNSScreenStackHeaderConfigBlurEffect &value) {
  switch (value) {
    case RNSScreenStackHeaderConfigBlurEffect::None: return "none";
    case RNSScreenStackHeaderConfigBlurEffect::ExtraLight: return "extraLight";
    case RNSScreenStackHeaderConfigBlurEffect::Light: return "light";
    case RNSScreenStackHeaderConfigBlurEffect::Dark: return "dark";
    case RNSScreenStackHeaderConfigBlurEffect::Regular: return "regular";
    case RNSScreenStackHeaderConfigBlurEffect::Prominent: return "prominent";
    case RNSScreenStackHeaderConfigBlurEffect::SystemUltraThinMaterial: return "systemUltraThinMaterial";
    case RNSScreenStackHeaderConfigBlurEffect::SystemThinMaterial: return "systemThinMaterial";
    case RNSScreenStackHeaderConfigBlurEffect::SystemMaterial: return "systemMaterial";
    case RNSScreenStackHeaderConfigBlurEffect::SystemThickMaterial: return "systemThickMaterial";
    case RNSScreenStackHeaderConfigBlurEffect::SystemChromeMaterial: return "systemChromeMaterial";
    case RNSScreenStackHeaderConfigBlurEffect::SystemUltraThinMaterialLight: return "systemUltraThinMaterialLight";
    case RNSScreenStackHeaderConfigBlurEffect::SystemThinMaterialLight: return "systemThinMaterialLight";
    case RNSScreenStackHeaderConfigBlurEffect::SystemMaterialLight: return "systemMaterialLight";
    case RNSScreenStackHeaderConfigBlurEffect::SystemThickMaterialLight: return "systemThickMaterialLight";
    case RNSScreenStackHeaderConfigBlurEffect::SystemChromeMaterialLight: return "systemChromeMaterialLight";
    case RNSScreenStackHeaderConfigBlurEffect::SystemUltraThinMaterialDark: return "systemUltraThinMaterialDark";
    case RNSScreenStackHeaderConfigBlurEffect::SystemThinMaterialDark: return "systemThinMaterialDark";
    case RNSScreenStackHeaderConfigBlurEffect::SystemMaterialDark: return "systemMaterialDark";
    case RNSScreenStackHeaderConfigBlurEffect::SystemThickMaterialDark: return "systemThickMaterialDark";
    case RNSScreenStackHeaderConfigBlurEffect::SystemChromeMaterialDark: return "systemChromeMaterialDark";
  }
}

#ifdef RN_SERIALIZABLE_STATE
static inline folly::dynamic toDynamic(const RNSScreenStackHeaderConfigBlurEffect &value) {
  return toString(value);
}
#endif
enum class RNSScreenStackHeaderConfigUserInterfaceStyle { Unspecified, Light, Dark };

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSScreenStackHeaderConfigUserInterfaceStyle &result) {
  auto string = (std::string)value;
  if (string == "unspecified") { result = RNSScreenStackHeaderConfigUserInterfaceStyle::Unspecified; return; }
  if (string == "light") { result = RNSScreenStackHeaderConfigUserInterfaceStyle::Light; return; }
  if (string == "dark") { result = RNSScreenStackHeaderConfigUserInterfaceStyle::Dark; return; }
  abort();
}

static inline std::string toString(const RNSScreenStackHeaderConfigUserInterfaceStyle &value) {
  switch (value) {
    case RNSScreenStackHeaderConfigUserInterfaceStyle::Unspecified: return "unspecified";
    case RNSScreenStackHeaderConfigUserInterfaceStyle::Light: return "light";
    case RNSScreenStackHeaderConfigUserInterfaceStyle::Dark: return "dark";
  }
}

#ifdef RN_SERIALIZABLE_STATE
static inline folly::dynamic toDynamic(const RNSScreenStackHeaderConfigUserInterfaceStyle &value) {
  return toString(value);
}
#endif

class RNSScreenStackHeaderConfigProps final : public ViewProps {
 public:
  RNSScreenStackHeaderConfigProps() = default;
  RNSScreenStackHeaderConfigProps(const PropsParserContext& context, const RNSScreenStackHeaderConfigProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  SharedColor backgroundColor{};
  std::string backTitle{};
  std::string backTitleFontFamily{};
  int backTitleFontSize{0};
  bool backTitleVisible{true};
  SharedColor color{};
  RNSScreenStackHeaderConfigDirection direction{RNSScreenStackHeaderConfigDirection::Ltr};
  bool hidden{false};
  bool hideShadow{false};
  bool largeTitle{false};
  std::string largeTitleFontFamily{};
  int largeTitleFontSize{0};
  std::string largeTitleFontWeight{};
  SharedColor largeTitleBackgroundColor{};
  bool largeTitleHideShadow{false};
  SharedColor largeTitleColor{};
  bool translucent{false};
  std::string title{};
  std::string titleFontFamily{};
  int titleFontSize{0};
  std::string titleFontWeight{};
  SharedColor titleColor{};
  bool disableBackButtonMenu{false};
  RNSScreenStackHeaderConfigBackButtonDisplayMode backButtonDisplayMode{RNSScreenStackHeaderConfigBackButtonDisplayMode::Default};
  bool hideBackButton{false};
  bool backButtonInCustomView{false};
  RNSScreenStackHeaderConfigBlurEffect blurEffect{RNSScreenStackHeaderConfigBlurEffect::None};
  bool topInsetEnabled{false};
  std::vector<folly::dynamic> headerLeftBarButtonItems{};
  std::vector<folly::dynamic> headerRightBarButtonItems{};
  bool synchronousShadowStateUpdatesEnabled{false};
  RNSScreenStackHeaderConfigUserInterfaceStyle userInterfaceStyle{RNSScreenStackHeaderConfigUserInterfaceStyle::Unspecified};

  #ifdef RN_SERIALIZABLE_STATE
  ComponentName getDiffPropsImplementationTarget() const override;

  folly::dynamic getDiffProps(const Props* prevProps) const override;
  #endif

  
};

enum class RNSScreenStackHeaderSubviewType { Back, Right, Left, Title, Center, SearchBar };

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSScreenStackHeaderSubviewType &result) {
  auto string = (std::string)value;
  if (string == "back") { result = RNSScreenStackHeaderSubviewType::Back; return; }
  if (string == "right") { result = RNSScreenStackHeaderSubviewType::Right; return; }
  if (string == "left") { result = RNSScreenStackHeaderSubviewType::Left; return; }
  if (string == "title") { result = RNSScreenStackHeaderSubviewType::Title; return; }
  if (string == "center") { result = RNSScreenStackHeaderSubviewType::Center; return; }
  if (string == "searchBar") { result = RNSScreenStackHeaderSubviewType::SearchBar; return; }
  abort();
}

static inline std::string toString(const RNSScreenStackHeaderSubviewType &value) {
  switch (value) {
    case RNSScreenStackHeaderSubviewType::Back: return "back";
    case RNSScreenStackHeaderSubviewType::Right: return "right";
    case RNSScreenStackHeaderSubviewType::Left: return "left";
    case RNSScreenStackHeaderSubviewType::Title: return "title";
    case RNSScreenStackHeaderSubviewType::Center: return "center";
    case RNSScreenStackHeaderSubviewType::SearchBar: return "searchBar";
  }
}

#ifdef RN_SERIALIZABLE_STATE
static inline folly::dynamic toDynamic(const RNSScreenStackHeaderSubviewType &value) {
  return toString(value);
}
#endif

class RNSScreenStackHeaderSubviewProps final : public ViewProps {
 public:
  RNSScreenStackHeaderSubviewProps() = default;
  RNSScreenStackHeaderSubviewProps(const PropsParserContext& context, const RNSScreenStackHeaderSubviewProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  RNSScreenStackHeaderSubviewType type{RNSScreenStackHeaderSubviewType::Left};
  bool hidesSharedBackground{false};
  bool synchronousShadowStateUpdatesEnabled{false};

  #ifdef RN_SERIALIZABLE_STATE
  ComponentName getDiffPropsImplementationTarget() const override;

  folly::dynamic getDiffProps(const Props* prevProps) const override;
  #endif

  
};

class RNSScreenStackProps final : public ViewProps {
 public:
  RNSScreenStackProps() = default;
  RNSScreenStackProps(const PropsParserContext& context, const RNSScreenStackProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  bool iosPreventReattachmentOfDismissedScreens{true};

  #ifdef RN_SERIALIZABLE_STATE
  ComponentName getDiffPropsImplementationTarget() const override;

  folly::dynamic getDiffProps(const Props* prevProps) const override;
  #endif

  
};

enum class RNSSearchBarAutoCapitalize { SystemDefault, None, Words, Sentences, Characters };

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSSearchBarAutoCapitalize &result) {
  auto string = (std::string)value;
  if (string == "systemDefault") { result = RNSSearchBarAutoCapitalize::SystemDefault; return; }
  if (string == "none") { result = RNSSearchBarAutoCapitalize::None; return; }
  if (string == "words") { result = RNSSearchBarAutoCapitalize::Words; return; }
  if (string == "sentences") { result = RNSSearchBarAutoCapitalize::Sentences; return; }
  if (string == "characters") { result = RNSSearchBarAutoCapitalize::Characters; return; }
  abort();
}

static inline std::string toString(const RNSSearchBarAutoCapitalize &value) {
  switch (value) {
    case RNSSearchBarAutoCapitalize::SystemDefault: return "systemDefault";
    case RNSSearchBarAutoCapitalize::None: return "none";
    case RNSSearchBarAutoCapitalize::Words: return "words";
    case RNSSearchBarAutoCapitalize::Sentences: return "sentences";
    case RNSSearchBarAutoCapitalize::Characters: return "characters";
  }
}

#ifdef RN_SERIALIZABLE_STATE
static inline folly::dynamic toDynamic(const RNSSearchBarAutoCapitalize &value) {
  return toString(value);
}
#endif
enum class RNSSearchBarPlacement { Automatic, Inline, Stacked, Integrated, IntegratedButton, IntegratedCentered };

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSSearchBarPlacement &result) {
  auto string = (std::string)value;
  if (string == "automatic") { result = RNSSearchBarPlacement::Automatic; return; }
  if (string == "inline") { result = RNSSearchBarPlacement::Inline; return; }
  if (string == "stacked") { result = RNSSearchBarPlacement::Stacked; return; }
  if (string == "integrated") { result = RNSSearchBarPlacement::Integrated; return; }
  if (string == "integratedButton") { result = RNSSearchBarPlacement::IntegratedButton; return; }
  if (string == "integratedCentered") { result = RNSSearchBarPlacement::IntegratedCentered; return; }
  abort();
}

static inline std::string toString(const RNSSearchBarPlacement &value) {
  switch (value) {
    case RNSSearchBarPlacement::Automatic: return "automatic";
    case RNSSearchBarPlacement::Inline: return "inline";
    case RNSSearchBarPlacement::Stacked: return "stacked";
    case RNSSearchBarPlacement::Integrated: return "integrated";
    case RNSSearchBarPlacement::IntegratedButton: return "integratedButton";
    case RNSSearchBarPlacement::IntegratedCentered: return "integratedCentered";
  }
}

#ifdef RN_SERIALIZABLE_STATE
static inline folly::dynamic toDynamic(const RNSSearchBarPlacement &value) {
  return toString(value);
}
#endif
enum class RNSSearchBarObscureBackground { Undefined, False, True };

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSSearchBarObscureBackground &result) {
  auto string = (std::string)value;
  if (string == "undefined") { result = RNSSearchBarObscureBackground::Undefined; return; }
  if (string == "false") { result = RNSSearchBarObscureBackground::False; return; }
  if (string == "true") { result = RNSSearchBarObscureBackground::True; return; }
  abort();
}

static inline std::string toString(const RNSSearchBarObscureBackground &value) {
  switch (value) {
    case RNSSearchBarObscureBackground::Undefined: return "undefined";
    case RNSSearchBarObscureBackground::False: return "false";
    case RNSSearchBarObscureBackground::True: return "true";
  }
}

#ifdef RN_SERIALIZABLE_STATE
static inline folly::dynamic toDynamic(const RNSSearchBarObscureBackground &value) {
  return toString(value);
}
#endif
enum class RNSSearchBarHideNavigationBar { Undefined, False, True };

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSSearchBarHideNavigationBar &result) {
  auto string = (std::string)value;
  if (string == "undefined") { result = RNSSearchBarHideNavigationBar::Undefined; return; }
  if (string == "false") { result = RNSSearchBarHideNavigationBar::False; return; }
  if (string == "true") { result = RNSSearchBarHideNavigationBar::True; return; }
  abort();
}

static inline std::string toString(const RNSSearchBarHideNavigationBar &value) {
  switch (value) {
    case RNSSearchBarHideNavigationBar::Undefined: return "undefined";
    case RNSSearchBarHideNavigationBar::False: return "false";
    case RNSSearchBarHideNavigationBar::True: return "true";
  }
}

#ifdef RN_SERIALIZABLE_STATE
static inline folly::dynamic toDynamic(const RNSSearchBarHideNavigationBar &value) {
  return toString(value);
}
#endif

class RNSSearchBarProps final : public ViewProps {
 public:
  RNSSearchBarProps() = default;
  RNSSearchBarProps(const PropsParserContext& context, const RNSSearchBarProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  bool hideWhenScrolling{true};
  RNSSearchBarAutoCapitalize autoCapitalize{RNSSearchBarAutoCapitalize::SystemDefault};
  std::string placeholder{};
  RNSSearchBarPlacement placement{RNSSearchBarPlacement::Automatic};
  bool allowToolbarIntegration{true};
  RNSSearchBarObscureBackground obscureBackground{RNSSearchBarObscureBackground::Undefined};
  RNSSearchBarHideNavigationBar hideNavigationBar{RNSSearchBarHideNavigationBar::Undefined};
  std::string cancelButtonText{};
  SharedColor barTintColor{};
  SharedColor tintColor{};
  SharedColor textColor{};
  bool autoFocus{false};
  bool disableBackButtonOverride{false};
  std::string inputType{};
  SharedColor hintTextColor{};
  SharedColor headerIconColor{};
  bool shouldShowHintSearchIcon{true};

  #ifdef RN_SERIALIZABLE_STATE
  ComponentName getDiffPropsImplementationTarget() const override;

  folly::dynamic getDiffProps(const Props* prevProps) const override;
  #endif

  
};

enum class RNSTabsBottomAccessoryContentEnvironment { Regular, Inline };

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSTabsBottomAccessoryContentEnvironment &result) {
  auto string = (std::string)value;
  if (string == "regular") { result = RNSTabsBottomAccessoryContentEnvironment::Regular; return; }
  if (string == "inline") { result = RNSTabsBottomAccessoryContentEnvironment::Inline; return; }
  abort();
}

static inline std::string toString(const RNSTabsBottomAccessoryContentEnvironment &value) {
  switch (value) {
    case RNSTabsBottomAccessoryContentEnvironment::Regular: return "regular";
    case RNSTabsBottomAccessoryContentEnvironment::Inline: return "inline";
  }
}

#ifdef RN_SERIALIZABLE_STATE
static inline folly::dynamic toDynamic(const RNSTabsBottomAccessoryContentEnvironment &value) {
  return toString(value);
}
#endif

class RNSTabsBottomAccessoryContentProps final : public ViewProps {
 public:
  RNSTabsBottomAccessoryContentProps() = default;
  RNSTabsBottomAccessoryContentProps(const PropsParserContext& context, const RNSTabsBottomAccessoryContentProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  RNSTabsBottomAccessoryContentEnvironment environment{RNSTabsBottomAccessoryContentEnvironment::Regular};

  #ifdef RN_SERIALIZABLE_STATE
  ComponentName getDiffPropsImplementationTarget() const override;

  folly::dynamic getDiffProps(const Props* prevProps) const override;
  #endif

  
};

class RNSTabsBottomAccessoryProps final : public ViewProps {
 public:
  RNSTabsBottomAccessoryProps() = default;
  RNSTabsBottomAccessoryProps(const PropsParserContext& context, const RNSTabsBottomAccessoryProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  

  #ifdef RN_SERIALIZABLE_STATE
  ComponentName getDiffPropsImplementationTarget() const override;

  folly::dynamic getDiffProps(const Props* prevProps) const override;
  #endif

  
};

enum class RNSTabsHostTabBarItemLabelVisibilityMode { Auto, Selected, Labeled, Unlabeled };

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSTabsHostTabBarItemLabelVisibilityMode &result) {
  auto string = (std::string)value;
  if (string == "auto") { result = RNSTabsHostTabBarItemLabelVisibilityMode::Auto; return; }
  if (string == "selected") { result = RNSTabsHostTabBarItemLabelVisibilityMode::Selected; return; }
  if (string == "labeled") { result = RNSTabsHostTabBarItemLabelVisibilityMode::Labeled; return; }
  if (string == "unlabeled") { result = RNSTabsHostTabBarItemLabelVisibilityMode::Unlabeled; return; }
  abort();
}

static inline std::string toString(const RNSTabsHostTabBarItemLabelVisibilityMode &value) {
  switch (value) {
    case RNSTabsHostTabBarItemLabelVisibilityMode::Auto: return "auto";
    case RNSTabsHostTabBarItemLabelVisibilityMode::Selected: return "selected";
    case RNSTabsHostTabBarItemLabelVisibilityMode::Labeled: return "labeled";
    case RNSTabsHostTabBarItemLabelVisibilityMode::Unlabeled: return "unlabeled";
  }
}

#ifdef RN_SERIALIZABLE_STATE
static inline folly::dynamic toDynamic(const RNSTabsHostTabBarItemLabelVisibilityMode &value) {
  return toString(value);
}
#endif
enum class RNSTabsHostTabBarMinimizeBehavior { Automatic, Never, OnScrollDown, OnScrollUp };

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSTabsHostTabBarMinimizeBehavior &result) {
  auto string = (std::string)value;
  if (string == "automatic") { result = RNSTabsHostTabBarMinimizeBehavior::Automatic; return; }
  if (string == "never") { result = RNSTabsHostTabBarMinimizeBehavior::Never; return; }
  if (string == "onScrollDown") { result = RNSTabsHostTabBarMinimizeBehavior::OnScrollDown; return; }
  if (string == "onScrollUp") { result = RNSTabsHostTabBarMinimizeBehavior::OnScrollUp; return; }
  abort();
}

static inline std::string toString(const RNSTabsHostTabBarMinimizeBehavior &value) {
  switch (value) {
    case RNSTabsHostTabBarMinimizeBehavior::Automatic: return "automatic";
    case RNSTabsHostTabBarMinimizeBehavior::Never: return "never";
    case RNSTabsHostTabBarMinimizeBehavior::OnScrollDown: return "onScrollDown";
    case RNSTabsHostTabBarMinimizeBehavior::OnScrollUp: return "onScrollUp";
  }
}

#ifdef RN_SERIALIZABLE_STATE
static inline folly::dynamic toDynamic(const RNSTabsHostTabBarMinimizeBehavior &value) {
  return toString(value);
}
#endif
enum class RNSTabsHostTabBarControllerMode { Automatic, TabBar, TabSidebar };

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSTabsHostTabBarControllerMode &result) {
  auto string = (std::string)value;
  if (string == "automatic") { result = RNSTabsHostTabBarControllerMode::Automatic; return; }
  if (string == "tabBar") { result = RNSTabsHostTabBarControllerMode::TabBar; return; }
  if (string == "tabSidebar") { result = RNSTabsHostTabBarControllerMode::TabSidebar; return; }
  abort();
}

static inline std::string toString(const RNSTabsHostTabBarControllerMode &value) {
  switch (value) {
    case RNSTabsHostTabBarControllerMode::Automatic: return "automatic";
    case RNSTabsHostTabBarControllerMode::TabBar: return "tabBar";
    case RNSTabsHostTabBarControllerMode::TabSidebar: return "tabSidebar";
  }
}

#ifdef RN_SERIALIZABLE_STATE
static inline folly::dynamic toDynamic(const RNSTabsHostTabBarControllerMode &value) {
  return toString(value);
}
#endif

class RNSTabsHostProps final : public ViewProps {
 public:
  RNSTabsHostProps() = default;
  RNSTabsHostProps(const PropsParserContext& context, const RNSTabsHostProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  bool tabBarHidden{false};
  SharedColor nativeContainerBackgroundColor{};
  SharedColor tabBarBackgroundColor{};
  std::string tabBarItemTitleFontFamily{};
  Float tabBarItemTitleFontSize{0.0};
  Float tabBarItemTitleFontSizeActive{0.0};
  std::string tabBarItemTitleFontWeight{};
  std::string tabBarItemTitleFontStyle{};
  SharedColor tabBarItemTitleFontColor{};
  SharedColor tabBarItemTitleFontColorActive{};
  SharedColor tabBarItemIconColor{};
  SharedColor tabBarItemIconColorActive{};
  SharedColor tabBarItemActiveIndicatorColor{};
  bool tabBarItemActiveIndicatorEnabled{true};
  SharedColor tabBarItemRippleColor{};
  RNSTabsHostTabBarItemLabelVisibilityMode tabBarItemLabelVisibilityMode{RNSTabsHostTabBarItemLabelVisibilityMode::Auto};
  SharedColor tabBarTintColor{};
  RNSTabsHostTabBarMinimizeBehavior tabBarMinimizeBehavior{RNSTabsHostTabBarMinimizeBehavior::Automatic};
  RNSTabsHostTabBarControllerMode tabBarControllerMode{RNSTabsHostTabBarControllerMode::Automatic};
  bool controlNavigationStateInJS{false};

  #ifdef RN_SERIALIZABLE_STATE
  ComponentName getDiffPropsImplementationTarget() const override;

  folly::dynamic getDiffProps(const Props* prevProps) const override;
  #endif

  
};

enum class RNSTabsScreenOrientation { Inherit, All, AllButUpsideDown, Portrait, PortraitUp, PortraitDown, Landscape, LandscapeLeft, LandscapeRight };

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSTabsScreenOrientation &result) {
  auto string = (std::string)value;
  if (string == "inherit") { result = RNSTabsScreenOrientation::Inherit; return; }
  if (string == "all") { result = RNSTabsScreenOrientation::All; return; }
  if (string == "allButUpsideDown") { result = RNSTabsScreenOrientation::AllButUpsideDown; return; }
  if (string == "portrait") { result = RNSTabsScreenOrientation::Portrait; return; }
  if (string == "portraitUp") { result = RNSTabsScreenOrientation::PortraitUp; return; }
  if (string == "portraitDown") { result = RNSTabsScreenOrientation::PortraitDown; return; }
  if (string == "landscape") { result = RNSTabsScreenOrientation::Landscape; return; }
  if (string == "landscapeLeft") { result = RNSTabsScreenOrientation::LandscapeLeft; return; }
  if (string == "landscapeRight") { result = RNSTabsScreenOrientation::LandscapeRight; return; }
  abort();
}

static inline std::string toString(const RNSTabsScreenOrientation &value) {
  switch (value) {
    case RNSTabsScreenOrientation::Inherit: return "inherit";
    case RNSTabsScreenOrientation::All: return "all";
    case RNSTabsScreenOrientation::AllButUpsideDown: return "allButUpsideDown";
    case RNSTabsScreenOrientation::Portrait: return "portrait";
    case RNSTabsScreenOrientation::PortraitUp: return "portraitUp";
    case RNSTabsScreenOrientation::PortraitDown: return "portraitDown";
    case RNSTabsScreenOrientation::Landscape: return "landscape";
    case RNSTabsScreenOrientation::LandscapeLeft: return "landscapeLeft";
    case RNSTabsScreenOrientation::LandscapeRight: return "landscapeRight";
  }
}

#ifdef RN_SERIALIZABLE_STATE
static inline folly::dynamic toDynamic(const RNSTabsScreenOrientation &value) {
  return toString(value);
}
#endif
enum class RNSTabsScreenIconType { Image, Template, SfSymbol, Xcasset };

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSTabsScreenIconType &result) {
  auto string = (std::string)value;
  if (string == "image") { result = RNSTabsScreenIconType::Image; return; }
  if (string == "template") { result = RNSTabsScreenIconType::Template; return; }
  if (string == "sfSymbol") { result = RNSTabsScreenIconType::SfSymbol; return; }
  if (string == "xcasset") { result = RNSTabsScreenIconType::Xcasset; return; }
  abort();
}

static inline std::string toString(const RNSTabsScreenIconType &value) {
  switch (value) {
    case RNSTabsScreenIconType::Image: return "image";
    case RNSTabsScreenIconType::Template: return "template";
    case RNSTabsScreenIconType::SfSymbol: return "sfSymbol";
    case RNSTabsScreenIconType::Xcasset: return "xcasset";
  }
}

#ifdef RN_SERIALIZABLE_STATE
static inline folly::dynamic toDynamic(const RNSTabsScreenIconType &value) {
  return toString(value);
}
#endif
enum class RNSTabsScreenSystemItem { None, Bookmarks, Contacts, Downloads, Favorites, Featured, History, More, MostRecent, MostViewed, Recents, Search, TopRated };

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSTabsScreenSystemItem &result) {
  auto string = (std::string)value;
  if (string == "none") { result = RNSTabsScreenSystemItem::None; return; }
  if (string == "bookmarks") { result = RNSTabsScreenSystemItem::Bookmarks; return; }
  if (string == "contacts") { result = RNSTabsScreenSystemItem::Contacts; return; }
  if (string == "downloads") { result = RNSTabsScreenSystemItem::Downloads; return; }
  if (string == "favorites") { result = RNSTabsScreenSystemItem::Favorites; return; }
  if (string == "featured") { result = RNSTabsScreenSystemItem::Featured; return; }
  if (string == "history") { result = RNSTabsScreenSystemItem::History; return; }
  if (string == "more") { result = RNSTabsScreenSystemItem::More; return; }
  if (string == "mostRecent") { result = RNSTabsScreenSystemItem::MostRecent; return; }
  if (string == "mostViewed") { result = RNSTabsScreenSystemItem::MostViewed; return; }
  if (string == "recents") { result = RNSTabsScreenSystemItem::Recents; return; }
  if (string == "search") { result = RNSTabsScreenSystemItem::Search; return; }
  if (string == "topRated") { result = RNSTabsScreenSystemItem::TopRated; return; }
  abort();
}

static inline std::string toString(const RNSTabsScreenSystemItem &value) {
  switch (value) {
    case RNSTabsScreenSystemItem::None: return "none";
    case RNSTabsScreenSystemItem::Bookmarks: return "bookmarks";
    case RNSTabsScreenSystemItem::Contacts: return "contacts";
    case RNSTabsScreenSystemItem::Downloads: return "downloads";
    case RNSTabsScreenSystemItem::Favorites: return "favorites";
    case RNSTabsScreenSystemItem::Featured: return "featured";
    case RNSTabsScreenSystemItem::History: return "history";
    case RNSTabsScreenSystemItem::More: return "more";
    case RNSTabsScreenSystemItem::MostRecent: return "mostRecent";
    case RNSTabsScreenSystemItem::MostViewed: return "mostViewed";
    case RNSTabsScreenSystemItem::Recents: return "recents";
    case RNSTabsScreenSystemItem::Search: return "search";
    case RNSTabsScreenSystemItem::TopRated: return "topRated";
  }
}

#ifdef RN_SERIALIZABLE_STATE
static inline folly::dynamic toDynamic(const RNSTabsScreenSystemItem &value) {
  return toString(value);
}
#endif
enum class RNSTabsScreenBottomScrollEdgeEffect { Automatic, Hard, Soft, Hidden };

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSTabsScreenBottomScrollEdgeEffect &result) {
  auto string = (std::string)value;
  if (string == "automatic") { result = RNSTabsScreenBottomScrollEdgeEffect::Automatic; return; }
  if (string == "hard") { result = RNSTabsScreenBottomScrollEdgeEffect::Hard; return; }
  if (string == "soft") { result = RNSTabsScreenBottomScrollEdgeEffect::Soft; return; }
  if (string == "hidden") { result = RNSTabsScreenBottomScrollEdgeEffect::Hidden; return; }
  abort();
}

static inline std::string toString(const RNSTabsScreenBottomScrollEdgeEffect &value) {
  switch (value) {
    case RNSTabsScreenBottomScrollEdgeEffect::Automatic: return "automatic";
    case RNSTabsScreenBottomScrollEdgeEffect::Hard: return "hard";
    case RNSTabsScreenBottomScrollEdgeEffect::Soft: return "soft";
    case RNSTabsScreenBottomScrollEdgeEffect::Hidden: return "hidden";
  }
}

#ifdef RN_SERIALIZABLE_STATE
static inline folly::dynamic toDynamic(const RNSTabsScreenBottomScrollEdgeEffect &value) {
  return toString(value);
}
#endif
enum class RNSTabsScreenLeftScrollEdgeEffect { Automatic, Hard, Soft, Hidden };

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSTabsScreenLeftScrollEdgeEffect &result) {
  auto string = (std::string)value;
  if (string == "automatic") { result = RNSTabsScreenLeftScrollEdgeEffect::Automatic; return; }
  if (string == "hard") { result = RNSTabsScreenLeftScrollEdgeEffect::Hard; return; }
  if (string == "soft") { result = RNSTabsScreenLeftScrollEdgeEffect::Soft; return; }
  if (string == "hidden") { result = RNSTabsScreenLeftScrollEdgeEffect::Hidden; return; }
  abort();
}

static inline std::string toString(const RNSTabsScreenLeftScrollEdgeEffect &value) {
  switch (value) {
    case RNSTabsScreenLeftScrollEdgeEffect::Automatic: return "automatic";
    case RNSTabsScreenLeftScrollEdgeEffect::Hard: return "hard";
    case RNSTabsScreenLeftScrollEdgeEffect::Soft: return "soft";
    case RNSTabsScreenLeftScrollEdgeEffect::Hidden: return "hidden";
  }
}

#ifdef RN_SERIALIZABLE_STATE
static inline folly::dynamic toDynamic(const RNSTabsScreenLeftScrollEdgeEffect &value) {
  return toString(value);
}
#endif
enum class RNSTabsScreenRightScrollEdgeEffect { Automatic, Hard, Soft, Hidden };

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSTabsScreenRightScrollEdgeEffect &result) {
  auto string = (std::string)value;
  if (string == "automatic") { result = RNSTabsScreenRightScrollEdgeEffect::Automatic; return; }
  if (string == "hard") { result = RNSTabsScreenRightScrollEdgeEffect::Hard; return; }
  if (string == "soft") { result = RNSTabsScreenRightScrollEdgeEffect::Soft; return; }
  if (string == "hidden") { result = RNSTabsScreenRightScrollEdgeEffect::Hidden; return; }
  abort();
}

static inline std::string toString(const RNSTabsScreenRightScrollEdgeEffect &value) {
  switch (value) {
    case RNSTabsScreenRightScrollEdgeEffect::Automatic: return "automatic";
    case RNSTabsScreenRightScrollEdgeEffect::Hard: return "hard";
    case RNSTabsScreenRightScrollEdgeEffect::Soft: return "soft";
    case RNSTabsScreenRightScrollEdgeEffect::Hidden: return "hidden";
  }
}

#ifdef RN_SERIALIZABLE_STATE
static inline folly::dynamic toDynamic(const RNSTabsScreenRightScrollEdgeEffect &value) {
  return toString(value);
}
#endif
enum class RNSTabsScreenTopScrollEdgeEffect { Automatic, Hard, Soft, Hidden };

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSTabsScreenTopScrollEdgeEffect &result) {
  auto string = (std::string)value;
  if (string == "automatic") { result = RNSTabsScreenTopScrollEdgeEffect::Automatic; return; }
  if (string == "hard") { result = RNSTabsScreenTopScrollEdgeEffect::Hard; return; }
  if (string == "soft") { result = RNSTabsScreenTopScrollEdgeEffect::Soft; return; }
  if (string == "hidden") { result = RNSTabsScreenTopScrollEdgeEffect::Hidden; return; }
  abort();
}

static inline std::string toString(const RNSTabsScreenTopScrollEdgeEffect &value) {
  switch (value) {
    case RNSTabsScreenTopScrollEdgeEffect::Automatic: return "automatic";
    case RNSTabsScreenTopScrollEdgeEffect::Hard: return "hard";
    case RNSTabsScreenTopScrollEdgeEffect::Soft: return "soft";
    case RNSTabsScreenTopScrollEdgeEffect::Hidden: return "hidden";
  }
}

#ifdef RN_SERIALIZABLE_STATE
static inline folly::dynamic toDynamic(const RNSTabsScreenTopScrollEdgeEffect &value) {
  return toString(value);
}
#endif
enum class RNSTabsScreenUserInterfaceStyle { Unspecified, Light, Dark };

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSTabsScreenUserInterfaceStyle &result) {
  auto string = (std::string)value;
  if (string == "unspecified") { result = RNSTabsScreenUserInterfaceStyle::Unspecified; return; }
  if (string == "light") { result = RNSTabsScreenUserInterfaceStyle::Light; return; }
  if (string == "dark") { result = RNSTabsScreenUserInterfaceStyle::Dark; return; }
  abort();
}

static inline std::string toString(const RNSTabsScreenUserInterfaceStyle &value) {
  switch (value) {
    case RNSTabsScreenUserInterfaceStyle::Unspecified: return "unspecified";
    case RNSTabsScreenUserInterfaceStyle::Light: return "light";
    case RNSTabsScreenUserInterfaceStyle::Dark: return "dark";
  }
}

#ifdef RN_SERIALIZABLE_STATE
static inline folly::dynamic toDynamic(const RNSTabsScreenUserInterfaceStyle &value) {
  return toString(value);
}
#endif
struct RNSTabsScreenSpecialEffectsRepeatedTabSelectionStruct {
  bool popToRoot{true};
  bool scrollToTop{true};


#ifdef RN_SERIALIZABLE_STATE
  bool operator==(const RNSTabsScreenSpecialEffectsRepeatedTabSelectionStruct&) const = default;

  folly::dynamic toDynamic() const {
    folly::dynamic result = folly::dynamic::object();
    result["popToRoot"] = popToRoot;
    result["scrollToTop"] = scrollToTop;
    return result;
  }
#endif
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSTabsScreenSpecialEffectsRepeatedTabSelectionStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_popToRoot = map.find("popToRoot");
  if (tmp_popToRoot != map.end()) {
    fromRawValue(context, tmp_popToRoot->second, result.popToRoot);
  }
  auto tmp_scrollToTop = map.find("scrollToTop");
  if (tmp_scrollToTop != map.end()) {
    fromRawValue(context, tmp_scrollToTop->second, result.scrollToTop);
  }
}

static inline std::string toString(const RNSTabsScreenSpecialEffectsRepeatedTabSelectionStruct &value) {
  return "[Object RNSTabsScreenSpecialEffectsRepeatedTabSelectionStruct]";
}

#ifdef RN_SERIALIZABLE_STATE
static inline folly::dynamic toDynamic(const RNSTabsScreenSpecialEffectsRepeatedTabSelectionStruct &value) {
  return value.toDynamic();
}
#endif

struct RNSTabsScreenSpecialEffectsStruct {
  RNSTabsScreenSpecialEffectsRepeatedTabSelectionStruct repeatedTabSelection{};


#ifdef RN_SERIALIZABLE_STATE
  bool operator==(const RNSTabsScreenSpecialEffectsStruct&) const = default;

  folly::dynamic toDynamic() const {
    folly::dynamic result = folly::dynamic::object();
    result["repeatedTabSelection"] = ::facebook::react::toDynamic(repeatedTabSelection);
    return result;
  }
#endif
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSTabsScreenSpecialEffectsStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_repeatedTabSelection = map.find("repeatedTabSelection");
  if (tmp_repeatedTabSelection != map.end()) {
    fromRawValue(context, tmp_repeatedTabSelection->second, result.repeatedTabSelection);
  }
}

static inline std::string toString(const RNSTabsScreenSpecialEffectsStruct &value) {
  return "[Object RNSTabsScreenSpecialEffectsStruct]";
}

#ifdef RN_SERIALIZABLE_STATE
static inline folly::dynamic toDynamic(const RNSTabsScreenSpecialEffectsStruct &value) {
  return value.toDynamic();
}
#endif
class RNSTabsScreenProps final : public ViewProps {
 public:
  RNSTabsScreenProps() = default;
  RNSTabsScreenProps(const PropsParserContext& context, const RNSTabsScreenProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  bool isFocused{false};
  std::string tabKey{};
  std::string title{};
  bool isTitleUndefined{true};
  std::string badgeValue{};
  std::string tabBarItemTestID{};
  std::string tabBarItemAccessibilityLabel{};
  RNSTabsScreenOrientation orientation{RNSTabsScreenOrientation::Inherit};
  std::string drawableIconResourceName{};
  ImageSource imageIconResource{};
  SharedColor tabBarItemBadgeTextColor{};
  SharedColor tabBarItemBadgeBackgroundColor{};
  folly::dynamic standardAppearance{};
  folly::dynamic scrollEdgeAppearance{};
  RNSTabsScreenIconType iconType{RNSTabsScreenIconType::SfSymbol};
  ImageSource iconImageSource{};
  std::string iconResourceName{};
  ImageSource selectedIconImageSource{};
  std::string selectedIconResourceName{};
  RNSTabsScreenSystemItem systemItem{RNSTabsScreenSystemItem::None};
  RNSTabsScreenSpecialEffectsStruct specialEffects{};
  bool overrideScrollViewContentInsetAdjustmentBehavior{true};
  RNSTabsScreenBottomScrollEdgeEffect bottomScrollEdgeEffect{RNSTabsScreenBottomScrollEdgeEffect::Automatic};
  RNSTabsScreenLeftScrollEdgeEffect leftScrollEdgeEffect{RNSTabsScreenLeftScrollEdgeEffect::Automatic};
  RNSTabsScreenRightScrollEdgeEffect rightScrollEdgeEffect{RNSTabsScreenRightScrollEdgeEffect::Automatic};
  RNSTabsScreenTopScrollEdgeEffect topScrollEdgeEffect{RNSTabsScreenTopScrollEdgeEffect::Automatic};
  RNSTabsScreenUserInterfaceStyle userInterfaceStyle{RNSTabsScreenUserInterfaceStyle::Unspecified};

  #ifdef RN_SERIALIZABLE_STATE
  ComponentName getDiffPropsImplementationTarget() const override;

  folly::dynamic getDiffProps(const Props* prevProps) const override;
  #endif

  
};

} // namespace facebook::react
